#include <ultra64.h>
#include "constants.h"
#include "game/room.h"
#include "bss.h"
#include "lib/mtx.h"
#include "data.h"
#include "types.h"

u8 *var800a6660;
s16 *var800a6664; // room numbers
s16 *var800a6668;
f32 *var800a666c;
Mtxf *var800a6670;

s32 var80082050 = 0;

void roomSetLastForOffset(s32 room)
{
	g_Vars.currentplayer->lastroomforoffset = room;
}

void room0f1668f0(s32 index, s32 roomnum)
{
	g_Rooms[roomnum].unk10 = index;
	var800a6664[index] = roomnum;
}

void room0f16692c(s32 index, s32 roomnum)
{
	g_Rooms[roomnum].unk10 = -1;
	var800a6664[index] = -1;
}

void room0f16696c(s32 index)
{
	if (var800a6664[index] != -1) {
		room0f16692c(index, var800a6664[index]);
	}

	var800a6660[index] = 2;
	var800a6668[index] = -1;
	var800a666c[index] = 1;
}

s32 room0f1669fc(void)
{
	s32 i;

	for (i = 0; i < var80082050; i++) {
		if (var800a6660[i] > 1 && var800a6668[i] == -1) {
			return i;
		}
	}

	return 0;
}

void room0f166a6c(Mtxf *mtx, s32 roomnum)
{
	s32 stagenum = g_Vars.stagenum;

	mtx4LoadIdentity(mtx);

	mtx->m[0][0] = 1;
	mtx->m[1][1] = 1;
	mtx->m[2][2] = 1;

	// These are rooms that are always active, such as the moon in Defection.
	// This is probably making those rooms always drawn a certain distance away
	// relative to the camera, so the moon never gets bigger as you go closer.
	if (((stagenum == g_Stages[STAGEINDEX_INFILTRATION].id
					|| stagenum == g_Stages[STAGEINDEX_RESCUE].id
					|| stagenum == g_Stages[STAGEINDEX_ESCAPE].id
					|| stagenum == g_Stages[STAGEINDEX_MAIANSOS].id) && roomnum == 0x0f)
			|| ((stagenum == g_Stages[STAGEINDEX_SKEDARRUINS].id
					|| stagenum == g_Stages[STAGEINDEX_WAR].id) && roomnum == 0x02)
			|| ((stagenum == g_Stages[STAGEINDEX_DEFECTION].id
					|| stagenum == g_Stages[STAGEINDEX_EXTRACTION].id
					|| stagenum == g_Stages[STAGEINDEX_MBR].id) && roomnum == 0x01)
			|| (stagenum == g_Stages[STAGEINDEX_ATTACKSHIP].id && roomnum == 0x71)) {
		mtx->m[3][0] = g_BgRooms[roomnum].pos.x;
		mtx->m[3][1] = g_BgRooms[roomnum].pos.y;
		mtx->m[3][2] = g_BgRooms[roomnum].pos.z;
	} else {
		mtx->m[3][0] = g_BgRooms[roomnum].pos.x - g_Vars.currentplayer->globaldrawworldoffset.x;
		mtx->m[3][1] = g_BgRooms[roomnum].pos.y - g_Vars.currentplayer->globaldrawworldoffset.y;
		mtx->m[3][2] = g_BgRooms[roomnum].pos.z - g_Vars.currentplayer->globaldrawworldoffset.z;
	}
}

s32 room0f166c20(s32 roomnum)
{
	s32 index = g_Rooms[roomnum].unk10;
	Mtxf mtx;

	if (index == -1
			|| g_Vars.currentplayer->lastroomforoffset != var800a6668[index]
			|| var800a666c[index] != var8005ef10[0]) {
		if (index != -1) {
			room0f16692c(index, roomnum);
		}

		index = room0f1669fc();

		room0f1668f0(index, roomnum);
		var800a6660[index] = 0;
	} else {
		var800a6660[index] = 0;
		return index;
	}

	var800a6668[index] = g_Vars.currentplayer->lastroomforoffset;
	var800a666c[index] = var8005ef10[0];

	room0f166a6c(&mtx, roomnum);
	mtx00016054(&mtx, &var800a6670[index]);

	return index;
}

Gfx *roomPushMtx(Gfx *gdl, s32 roomnum)
{
	s32 index = room0f166c20(roomnum);

	gSPMatrix(gdl++, &var800a6670[index], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);

	return gdl;
}

struct coord *roomGetPos(s32 room)
{
	return &g_BgRooms[room].pos;
}

void room0f166df0(s32 room, struct coord *globaldrawworldoffset)
{
	globaldrawworldoffset->x = g_BgRooms[room].pos.x;
	globaldrawworldoffset->y = g_BgRooms[room].pos.y;
	globaldrawworldoffset->z = g_BgRooms[room].pos.z;
}
